<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Class template unordered_map</title>
<link rel="stylesheet" href="../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../unordered/reference.html#header.boost.unordered_map_hpp" title="Header &lt;boost/unordered_map.hpp&gt;">
<link rel="prev" href="unordered_multiset.html" title="Class template unordered_multiset">
<link rel="next" href="unordered_multimap.html" title="Class template unordered_multimap">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="unordered_multiset.html"><img src="../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../unordered/reference.html#header.boost.unordered_map_hpp"><img src="../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="unordered_multimap.html"><img src="../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="refentry">
<a name="boost.unordered_map"></a><div class="titlepage"></div>
<div class="refnamediv">
<h2><span class="refentrytitle">Class template unordered_map</span></h2>
<p>boost::unordered_map &#8212; 
            An unordered associative container that associates unique keys with another value.
          </p>
</div>
<h2 xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv-title">Synopsis</h2>
<div xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv"><pre class="synopsis"><span class="comment">// In header: &lt;<a class="link" href="../unordered/reference.html#header.boost.unordered_map_hpp" title="Header &lt;boost/unordered_map.hpp&gt;">boost/unordered_map.hpp</a>&gt;

</span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Key<span class="special">,</span> <span class="keyword">typename</span> Mapped<span class="special">,</span> <span class="keyword">typename</span> Hash <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">hash</span><span class="special">&lt;</span><span class="identifier">Key</span><span class="special">&gt;</span><span class="special">,</span> 
         <span class="keyword">typename</span> Pred <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">equal_to</span><span class="special">&lt;</span><span class="identifier">Key</span><span class="special">&gt;</span><span class="special">,</span> 
         <span class="keyword">typename</span> Alloc <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Key</span> <span class="keyword">const</span><span class="special">,</span> <span class="identifier">Mapped</span><span class="special">&gt;&gt;</span> <span class="special">&gt;</span> 
<span class="keyword">class</span> <a class="link" href="unordered_map.html" title="Class template unordered_map">unordered_map</a> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
  <span class="comment">// <a class="link" href="unordered_map.html#boost.unordered_maptypes">types</a></span>
  <span class="keyword">typedef</span> <span class="identifier">Key</span>                                    <a name="boost.unordered_map.key_type"></a><span class="identifier">key_type</span><span class="special">;</span>            
  <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Key</span> <span class="keyword">const</span><span class="special">,</span> <span class="identifier">Mapped</span><span class="special">&gt;</span>           <a name="boost.unordered_map.value_type"></a><span class="identifier">value_type</span><span class="special">;</span>          
  <span class="keyword">typedef</span> <span class="identifier">Mapped</span>                                 <a name="boost.unordered_map.mapped_type"></a><span class="identifier">mapped_type</span><span class="special">;</span>         
  <span class="keyword">typedef</span> <span class="identifier">Hash</span>                                   <a name="boost.unordered_map.hasher"></a><span class="identifier">hasher</span><span class="special">;</span>              
  <span class="keyword">typedef</span> <span class="identifier">Pred</span>                                   <a name="boost.unordered_map.key_equal"></a><span class="identifier">key_equal</span><span class="special">;</span>           
  <span class="keyword">typedef</span> <span class="identifier">Alloc</span>                                  <a name="boost.unordered_map.allocator_type"></a><span class="identifier">allocator_type</span><span class="special">;</span>      
  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">allocator_type</span><span class="special">::</span><span class="identifier">pointer</span>       <a class="link" href="unordered_map.html#boost.unordered_map.pointer"><span class="identifier">pointer</span></a><span class="special">;</span>             
  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">allocator_type</span><span class="special">::</span><span class="identifier">const_pointer</span> <a class="link" href="unordered_map.html#boost.unordered_map.const_pointer"><span class="identifier">const_pointer</span></a><span class="special">;</span>       
  <span class="keyword">typedef</span> <span class="identifier">value_type</span><span class="special">&amp;</span>                            <a name="boost.unordered_map.reference"></a><span class="identifier">reference</span><span class="special">;</span>             <span class="comment">// lvalue of value_type.</span>
  <span class="keyword">typedef</span> <span class="identifier">value_type</span> <span class="keyword">const</span><span class="special">&amp;</span>                      <a name="boost.unordered_map.const_reference"></a><span class="identifier">const_reference</span><span class="special">;</span>       <span class="comment">// const lvalue of value_type.</span>
  <span class="keyword">typedef</span> <span class="emphasis"><em><span class="identifier">implementation</span><span class="special">-</span><span class="identifier">defined</span></em></span>                 <a class="link" href="unordered_map.html#boost.unordered_map.size_type"><span class="identifier">size_type</span></a><span class="special">;</span>           
  <span class="keyword">typedef</span> <span class="emphasis"><em><span class="identifier">implementation</span><span class="special">-</span><span class="identifier">defined</span></em></span>                 <a class="link" href="unordered_map.html#boost.unordered_map.difference_type"><span class="identifier">difference_type</span></a><span class="special">;</span>     
  <span class="keyword">typedef</span> <span class="emphasis"><em><span class="identifier">implementation</span><span class="special">-</span><span class="identifier">defined</span></em></span>                 <a class="link" href="unordered_map.html#boost.unordered_map.iterator"><span class="identifier">iterator</span></a><span class="special">;</span>            
  <span class="keyword">typedef</span> <span class="emphasis"><em><span class="identifier">implementation</span><span class="special">-</span><span class="identifier">defined</span></em></span>                 <a class="link" href="unordered_map.html#boost.unordered_map.const_iterator"><span class="identifier">const_iterator</span></a><span class="special">;</span>      
  <span class="keyword">typedef</span> <span class="emphasis"><em><span class="identifier">implementation</span><span class="special">-</span><span class="identifier">defined</span></em></span>                 <a class="link" href="unordered_map.html#boost.unordered_map.local_iterator"><span class="identifier">local_iterator</span></a><span class="special">;</span>      
  <span class="keyword">typedef</span> <span class="emphasis"><em><span class="identifier">implementation</span><span class="special">-</span><span class="identifier">defined</span></em></span>                 <a class="link" href="unordered_map.html#boost.unordered_map.const_local_iterator"><span class="identifier">const_local_iterator</span></a><span class="special">;</span>

  <span class="comment">// <a class="link" href="unordered_map.html#boost.unordered_mapconstruct-copy-destruct">construct/copy/destruct</a></span>
  <span class="keyword">explicit</span> <a class="link" href="unordered_map.html#id1640360-bb"><span class="identifier">unordered_map</span></a><span class="special">(</span><span class="identifier">size_type</span> <span class="special">=</span> <span class="emphasis"><em><span class="identifier">implementation</span><span class="special">-</span><span class="identifier">defined</span></em></span><span class="special">,</span> 
                         <span class="identifier">hasher</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="special">=</span> <span class="identifier">hasher</span><span class="special">(</span><span class="special">)</span><span class="special">,</span> 
                         <span class="identifier">key_equal</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="special">=</span> <span class="identifier">key_equal</span><span class="special">(</span><span class="special">)</span><span class="special">,</span> 
                         <span class="identifier">allocator_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="special">=</span> <span class="identifier">allocator_type</span><span class="special">(</span><span class="special">)</span><span class="special">)</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <a class="link" href="../InputIterator.html" title="Concept InputIterator">InputIterator</a><span class="special">&gt;</span> 
    <a class="link" href="unordered_map.html#id1640442-bb"><span class="identifier">unordered_map</span></a><span class="special">(</span><span class="identifier">InputIterator</span><span class="special">,</span> <span class="identifier">InputIterator</span><span class="special">,</span> 
                  <span class="identifier">size_type</span> <span class="special">=</span> <span class="emphasis"><em><span class="identifier">implementation</span><span class="special">-</span><span class="identifier">defined</span></em></span><span class="special">,</span> 
                  <span class="identifier">hasher</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="special">=</span> <span class="identifier">hasher</span><span class="special">(</span><span class="special">)</span><span class="special">,</span> <span class="identifier">key_equal</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="special">=</span> <span class="identifier">key_equal</span><span class="special">(</span><span class="special">)</span><span class="special">,</span> 
                  <span class="identifier">allocator_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="special">=</span> <span class="identifier">allocator_type</span><span class="special">(</span><span class="special">)</span><span class="special">)</span><span class="special">;</span>
  <a class="link" href="unordered_map.html#id1639432-bb"><span class="identifier">unordered_map</span></a><span class="special">(</span><span class="identifier">unordered_map</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="special">)</span><span class="special">;</span>
  <a class="link" href="unordered_map.html#id1639473-bb"><span class="identifier">unordered_map</span></a><span class="special">(</span><span class="identifier">unordered_map</span> <span class="special">&amp;&amp;</span><span class="special">)</span><span class="special">;</span>
  <span class="keyword">explicit</span> <a class="link" href="unordered_map.html#id1639528-bb"><span class="identifier">unordered_map</span></a><span class="special">(</span><span class="identifier">Allocator</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="special">)</span><span class="special">;</span>
  <a class="link" href="unordered_map.html#id1639338-bb"><span class="identifier">unordered_map</span></a><span class="special">(</span><span class="identifier">unordered_map</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="special">,</span> <span class="identifier">Allocator</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="special">)</span><span class="special">;</span>
  <a class="link" href="unordered_map.html#id1639178-bb"><span class="special">~</span><span class="identifier">unordered_map</span></a><span class="special">(</span><span class="special">)</span><span class="special">;</span>
  <span class="identifier">unordered_map</span><span class="special">&amp;</span> <a class="link" href="unordered_map.html#id1639190-bb"><span class="keyword">operator</span><span class="special">=</span></a><span class="special">(</span><span class="identifier">unordered_map</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="special">)</span><span class="special">;</span>
  <span class="identifier">unordered_map</span><span class="special">&amp;</span> <a class="link" href="unordered_map.html#id1639242-bb"><span class="keyword">operator</span><span class="special">=</span></a><span class="special">(</span><span class="identifier">unordered_map</span> <span class="special">&amp;&amp;</span><span class="special">)</span><span class="special">;</span>
  <span class="identifier">allocator_type</span> <a class="link" href="unordered_map.html#id1639306-bb"><span class="identifier">get_allocator</span></a><span class="special">(</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>

  <span class="comment">// <a class="link" href="unordered_map.html#id1639317-bb">size and capacity</a></span>
  <span class="keyword">bool</span> <a class="link" href="unordered_map.html#id1639322-bb"><span class="identifier">empty</span></a><span class="special">(</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">size_type</span> <a class="link" href="unordered_map.html#id1637628-bb"><span class="identifier">size</span></a><span class="special">(</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">size_type</span> <a class="link" href="unordered_map.html#id1637655-bb"><span class="identifier">max_size</span></a><span class="special">(</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>

  <span class="comment">// <a class="link" href="unordered_map.html#id1637677-bb">iterators</a></span>
  <span class="identifier">iterator</span> <a class="link" href="unordered_map.html#id1637686-bb"><span class="identifier">begin</span></a><span class="special">(</span><span class="special">)</span><span class="special">;</span>
  <span class="identifier">const_iterator</span> <a class="link" href="unordered_map.html#id1637691-bb"><span class="identifier">begin</span></a><span class="special">(</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">iterator</span> <a class="link" href="unordered_map.html#id1637710-bb"><span class="identifier">end</span></a><span class="special">(</span><span class="special">)</span><span class="special">;</span>
  <span class="identifier">const_iterator</span> <a class="link" href="unordered_map.html#id1637718-bb"><span class="identifier">end</span></a><span class="special">(</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">const_iterator</span> <a class="link" href="unordered_map.html#id1637734-bb"><span class="identifier">cbegin</span></a><span class="special">(</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">const_iterator</span> <a class="link" href="unordered_map.html#id1637752-bb"><span class="identifier">cend</span></a><span class="special">(</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>

  <span class="comment">// <a class="link" href="unordered_map.html#id1637770-bb">modifiers</a></span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span><span class="special">...</span> Args<span class="special">&gt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">iterator</span><span class="special">,</span> <span class="keyword">bool</span><span class="special">&gt;</span> <a class="link" href="unordered_map.html#id1637775-bb"><span class="identifier">emplace</span></a><span class="special">(</span><span class="identifier">Args</span><span class="special">&amp;&amp;</span><span class="special">...</span><span class="special">)</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span><span class="special">...</span> Args<span class="special">&gt;</span> <span class="identifier">iterator</span> <a class="link" href="unordered_map.html#id1637901-bb"><span class="identifier">emplace_hint</span></a><span class="special">(</span><span class="identifier">const_iterator</span><span class="special">,</span> <span class="identifier">Args</span><span class="special">&amp;&amp;</span><span class="special">...</span><span class="special">)</span><span class="special">;</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">iterator</span><span class="special">,</span> <span class="keyword">bool</span><span class="special">&gt;</span> <a class="link" href="unordered_map.html#id1638047-bb"><span class="identifier">insert</span></a><span class="special">(</span><span class="identifier">value_type</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="special">)</span><span class="special">;</span>
  <span class="identifier">iterator</span> <a class="link" href="unordered_map.html#id1638122-bb"><span class="identifier">insert</span></a><span class="special">(</span><span class="identifier">const_iterator</span><span class="special">,</span> <span class="identifier">value_type</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="special">)</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <a class="link" href="../InputIterator.html" title="Concept InputIterator">InputIterator</a><span class="special">&gt;</span> <span class="keyword">void</span> <a class="link" href="unordered_map.html#id1638213-bb"><span class="identifier">insert</span></a><span class="special">(</span><span class="identifier">InputIterator</span><span class="special">,</span> <span class="identifier">InputIterator</span><span class="special">)</span><span class="special">;</span>
  <span class="identifier">iterator</span> <a class="link" href="unordered_map.html#id1638290-bb"><span class="identifier">erase</span></a><span class="special">(</span><span class="identifier">const_iterator</span><span class="special">)</span><span class="special">;</span>
  <span class="identifier">size_type</span> <a class="link" href="unordered_map.html#id1638363-bb"><span class="identifier">erase</span></a><span class="special">(</span><span class="identifier">key_type</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="special">)</span><span class="special">;</span>
  <span class="identifier">iterator</span> <a class="link" href="unordered_map.html#id1638418-bb"><span class="identifier">erase</span></a><span class="special">(</span><span class="identifier">const_iterator</span><span class="special">,</span> <span class="identifier">const_iterator</span><span class="special">)</span><span class="special">;</span>
  <span class="keyword">void</span> <a class="link" href="unordered_map.html#id1638498-bb"><span class="identifier">quick_erase</span></a><span class="special">(</span><span class="identifier">const_iterator</span><span class="special">)</span><span class="special">;</span>
  <span class="keyword">void</span> <a class="link" href="unordered_map.html#id1638567-bb"><span class="identifier">erase_return_void</span></a><span class="special">(</span><span class="identifier">const_iterator</span><span class="special">)</span><span class="special">;</span>
  <span class="keyword">void</span> <a class="link" href="unordered_map.html#id1638637-bb"><span class="identifier">clear</span></a><span class="special">(</span><span class="special">)</span><span class="special">;</span>
  <span class="keyword">void</span> <a class="link" href="unordered_map.html#id1638674-bb"><span class="identifier">swap</span></a><span class="special">(</span><span class="identifier">unordered_map</span><span class="special">&amp;</span><span class="special">)</span><span class="special">;</span>

  <span class="comment">// <a class="link" href="unordered_map.html#id1638745-bb">observers</a></span>
  <span class="identifier">hasher</span> <a class="link" href="unordered_map.html#id1638749-bb"><span class="identifier">hash_function</span></a><span class="special">(</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">key_equal</span> <a class="link" href="unordered_map.html#id1638765-bb"><span class="identifier">key_eq</span></a><span class="special">(</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>

  <span class="comment">// <a class="link" href="unordered_map.html#id1638783-bb">lookup</a></span>
  <span class="identifier">iterator</span> <a class="link" href="unordered_map.html#id1638792-bb"><span class="identifier">find</span></a><span class="special">(</span><span class="identifier">key_type</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="special">)</span><span class="special">;</span>
  <span class="identifier">const_iterator</span> <a class="link" href="unordered_map.html#id1638810-bb"><span class="identifier">find</span></a><span class="special">(</span><span class="identifier">key_type</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> CompatibleKey<span class="special">,</span> <span class="keyword">typename</span> CompatibleHash<span class="special">,</span> 
           <span class="keyword">typename</span> CompatiblePredicate<span class="special">&gt;</span> 
    <span class="identifier">iterator</span> <a class="link" href="unordered_map.html#id1638830-bb"><span class="identifier">find</span></a><span class="special">(</span><span class="identifier">CompatibleKey</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="special">,</span> <span class="identifier">CompatibleHash</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="special">,</span> 
                  <span class="identifier">CompatiblePredicate</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="special">)</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> CompatibleKey<span class="special">,</span> <span class="keyword">typename</span> CompatibleHash<span class="special">,</span> 
           <span class="keyword">typename</span> CompatiblePredicate<span class="special">&gt;</span> 
    <span class="identifier">const_iterator</span> 
    <a class="link" href="unordered_map.html#id1638889-bb"><span class="identifier">find</span></a><span class="special">(</span><span class="identifier">CompatibleKey</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="special">,</span> <span class="identifier">CompatibleHash</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="special">,</span> 
         <span class="identifier">CompatiblePredicate</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">size_type</span> <a class="link" href="unordered_map.html#id1638977-bb"><span class="identifier">count</span></a><span class="special">(</span><span class="identifier">key_type</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">iterator</span><span class="special">,</span> <span class="identifier">iterator</span><span class="special">&gt;</span> <a class="link" href="unordered_map.html#id1639015-bb"><span class="identifier">equal_range</span></a><span class="special">(</span><span class="identifier">key_type</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="special">)</span><span class="special">;</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">const_iterator</span><span class="special">,</span> <span class="identifier">const_iterator</span><span class="special">&gt;</span> <a class="link" href="unordered_map.html#id1639034-bb"><span class="identifier">equal_range</span></a><span class="special">(</span><span class="identifier">key_type</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">mapped_type</span><span class="special">&amp;</span> <a class="link" href="unordered_map.html#id1639084-bb"><span class="keyword">operator</span><span class="special">[</span><span class="special">]</span></a><span class="special">(</span><span class="identifier">key_type</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="special">)</span><span class="special">;</span>
  <span class="identifier">Mapped</span><span class="special">&amp;</span> <a class="link" href="unordered_map.html#id1639166-bb"><span class="identifier">at</span></a><span class="special">(</span><span class="identifier">key_type</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="special">)</span><span class="special">;</span>
  <span class="identifier">Mapped</span> <span class="keyword">const</span><span class="special">&amp;</span> <a class="link" href="unordered_map.html#id1637381-bb"><span class="identifier">at</span></a><span class="special">(</span><span class="identifier">key_type</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>

  <span class="comment">// <a class="link" href="unordered_map.html#id1637430-bb">bucket interface</a></span>
  <span class="identifier">size_type</span> <a class="link" href="unordered_map.html#id1637434-bb"><span class="identifier">bucket_count</span></a><span class="special">(</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">size_type</span> <a class="link" href="unordered_map.html#id1637454-bb"><span class="identifier">max_bucket_count</span></a><span class="special">(</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">size_type</span> <a class="link" href="unordered_map.html#id1637474-bb"><span class="identifier">bucket_size</span></a><span class="special">(</span><span class="identifier">size_type</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">size_type</span> <a class="link" href="unordered_map.html#id1637521-bb"><span class="identifier">bucket</span></a><span class="special">(</span><span class="identifier">key_type</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">local_iterator</span> <a class="link" href="unordered_map.html#id1637570-bb"><span class="identifier">begin</span></a><span class="special">(</span><span class="identifier">size_type</span><span class="special">)</span><span class="special">;</span>
  <span class="identifier">const_local_iterator</span> <a class="link" href="unordered_map.html#id1637588-bb"><span class="identifier">begin</span></a><span class="special">(</span><span class="identifier">size_type</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">local_iterator</span> <a class="link" href="unordered_map.html#id1634794-bb"><span class="identifier">end</span></a><span class="special">(</span><span class="identifier">size_type</span><span class="special">)</span><span class="special">;</span>
  <span class="identifier">const_local_iterator</span> <a class="link" href="unordered_map.html#id1634812-bb"><span class="identifier">end</span></a><span class="special">(</span><span class="identifier">size_type</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">const_local_iterator</span> <a class="link" href="unordered_map.html#id1636502-bb"><span class="identifier">cbegin</span></a><span class="special">(</span><span class="identifier">size_type</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">const_local_iterator</span> <a class="link" href="unordered_map.html#id1636550-bb"><span class="identifier">cend</span></a><span class="special">(</span><span class="identifier">size_type</span><span class="special">)</span><span class="special">;</span>

  <span class="comment">// <a class="link" href="unordered_map.html#id1636599-bb">hash policy</a></span>
  <span class="keyword">float</span> <a class="link" href="unordered_map.html#id1636603-bb"><span class="identifier">load_factor</span></a><span class="special">(</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="keyword">float</span> <a class="link" href="unordered_map.html#id1636623-bb"><span class="identifier">max_load_factor</span></a><span class="special">(</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="keyword">void</span> <a class="link" href="unordered_map.html#id1636643-bb"><span class="identifier">max_load_factor</span></a><span class="special">(</span><span class="keyword">float</span><span class="special">)</span><span class="special">;</span>
  <span class="keyword">void</span> <a class="link" href="unordered_map.html#id1636675-bb"><span class="identifier">rehash</span></a><span class="special">(</span><span class="identifier">size_type</span><span class="special">)</span><span class="special">;</span>
<span class="special">}</span><span class="special">;</span>

<span class="comment">// <a class="link" href="unordered_map.html#id1636725-bb">Equality Comparisons</a></span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Key<span class="special">,</span> <span class="keyword">typename</span> Mapped<span class="special">,</span> <span class="keyword">typename</span> Hash<span class="special">,</span> <span class="keyword">typename</span> Pred<span class="special">,</span> 
         <span class="keyword">typename</span> Alloc<span class="special">&gt;</span> 
  <span class="keyword">bool</span> <a class="link" href="unordered_map.html#boost.unordered_map.operator==_id1636730"><span class="keyword">operator</span><span class="special">==</span></a><span class="special">(</span><span class="identifier">unordered_map</span><span class="special">&lt;</span><span class="identifier">Key</span><span class="special">,</span> <span class="identifier">Mapped</span><span class="special">,</span> <span class="identifier">Hash</span><span class="special">,</span> <span class="identifier">Pred</span><span class="special">,</span> <span class="identifier">Alloc</span><span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="special">,</span> 
                  <span class="identifier">unordered_map</span><span class="special">&lt;</span><span class="identifier">Key</span><span class="special">,</span> <span class="identifier">Mapped</span><span class="special">,</span> <span class="identifier">Hash</span><span class="special">,</span> <span class="identifier">Pred</span><span class="special">,</span> <span class="identifier">Alloc</span><span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="special">)</span><span class="special">;</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Key<span class="special">,</span> <span class="keyword">typename</span> Mapped<span class="special">,</span> <span class="keyword">typename</span> Hash<span class="special">,</span> <span class="keyword">typename</span> Pred<span class="special">,</span> 
         <span class="keyword">typename</span> Alloc<span class="special">&gt;</span> 
  <span class="keyword">bool</span> <a class="link" href="unordered_map.html#boost.unordered_map.operator!=_id1636846"><span class="keyword">operator</span><span class="special">!=</span></a><span class="special">(</span><span class="identifier">unordered_map</span><span class="special">&lt;</span><span class="identifier">Key</span><span class="special">,</span> <span class="identifier">Mapped</span><span class="special">,</span> <span class="identifier">Hash</span><span class="special">,</span> <span class="identifier">Pred</span><span class="special">,</span> <span class="identifier">Alloc</span><span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="special">,</span> 
                  <span class="identifier">unordered_map</span><span class="special">&lt;</span><span class="identifier">Key</span><span class="special">,</span> <span class="identifier">Mapped</span><span class="special">,</span> <span class="identifier">Hash</span><span class="special">,</span> <span class="identifier">Pred</span><span class="special">,</span> <span class="identifier">Alloc</span><span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="special">)</span><span class="special">;</span>

<span class="comment">// <a class="link" href="unordered_map.html#id1636963-bb">swap</a></span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Key<span class="special">,</span> <span class="keyword">typename</span> Mapped<span class="special">,</span> <span class="keyword">typename</span> Hash<span class="special">,</span> <span class="keyword">typename</span> Pred<span class="special">,</span> 
         <span class="keyword">typename</span> Alloc<span class="special">&gt;</span> 
  <span class="keyword">void</span> <a class="link" href="unordered_map.html#boost.unordered_map.swap_id1636968"><span class="identifier">swap</span></a><span class="special">(</span><span class="identifier">unordered_map</span><span class="special">&lt;</span><span class="identifier">Key</span><span class="special">,</span> <span class="identifier">Mapped</span><span class="special">,</span> <span class="identifier">Hash</span><span class="special">,</span> <span class="identifier">Pred</span><span class="special">,</span> <span class="identifier">Alloc</span><span class="special">&gt;</span><span class="special">&amp;</span><span class="special">,</span> 
            <span class="identifier">unordered_map</span><span class="special">&lt;</span><span class="identifier">Key</span><span class="special">,</span> <span class="identifier">Mapped</span><span class="special">,</span> <span class="identifier">Hash</span><span class="special">,</span> <span class="identifier">Pred</span><span class="special">,</span> <span class="identifier">Alloc</span><span class="special">&gt;</span><span class="special">&amp;</span><span class="special">)</span><span class="special">;</span></pre></div>
<div class="refsect1">
<a name="id3677598"></a><h2>Description</h2>
<p><span class="bold"><strong>Template Parameters</strong></span>
              </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td><span class="emphasis"><em>Key</em></span></td>
<td>Key must be Assignable and CopyConstructible.</td>
</tr>
<tr>
<td><span class="emphasis"><em>Mapped</em></span></td>
<td>Mapped must be CopyConstructible</td>
</tr>
<tr>
<td><span class="emphasis"><em>Hash</em></span></td>
<td>A unary function object type that acts a hash function for a <code class="computeroutput">Key</code>. It takes a single argument of type <code class="computeroutput">Key</code> and returns a value of type std::size_t.</td>
</tr>
<tr>
<td><span class="emphasis"><em>Pred</em></span></td>
<td>A binary function object that implements an equivalence relation on values of type <code class="computeroutput">Key</code>.
                        A binary function object that induces an equivalence relation on values of type <code class="computeroutput">Key</code>.
                        It takes two arguments of type <code class="computeroutput">Key</code> and returns a value of type bool.</td>
</tr>
<tr>
<td><span class="emphasis"><em>Alloc</em></span></td>
<td>An allocator whose value type is the same as the container's value type.</td>
</tr>
</tbody>
</table></div>
<p>The elements are organized into buckets. Keys with the same hash code are stored in the same bucket.</p>
<p>The number of buckets can be automatically increased by a call to insert, or as the result of calling rehash.</p>
<div class="refsect2">
<a name="id3677715"></a><h3>
<a name="boost.unordered_maptypes"></a><code class="computeroutput">unordered_map</code> 
        public
       types</h3>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<p>
<span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">allocator_type</span><span class="special">::</span><span class="identifier">pointer</span> <a name="boost.unordered_map.pointer"></a><span class="identifier">pointer</span><span class="special">;</span></p>
<p>
                <code class="computeroutput">value_type*</code> if
                <code class="computeroutput">allocator_type::pointer</code> is not defined.
              </p>
</li>
<li class="listitem">
<p>
<span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">allocator_type</span><span class="special">::</span><span class="identifier">const_pointer</span> <a name="boost.unordered_map.const_pointer"></a><span class="identifier">const_pointer</span><span class="special">;</span></p>
<p>
                <code class="computeroutput">boost::pointer_to_other&lt;pointer, value_type&gt;::type</code>
                if <code class="computeroutput">allocator_type::const_pointer</code> is not defined.
              </p>
</li>
<li class="listitem">
<p>
<span class="keyword">typedef</span> <span class="emphasis"><em><span class="identifier">implementation</span><span class="special">-</span><span class="identifier">defined</span></em></span> <a name="boost.unordered_map.size_type"></a><span class="identifier">size_type</span><span class="special">;</span></p>
<p>An unsigned integral type.</p>
<p>size_type can represent any non-negative value of difference_type.</p>
</li>
<li class="listitem">
<p>
<span class="keyword">typedef</span> <span class="emphasis"><em><span class="identifier">implementation</span><span class="special">-</span><span class="identifier">defined</span></em></span> <a name="boost.unordered_map.difference_type"></a><span class="identifier">difference_type</span><span class="special">;</span></p>
<p>A signed integral type.</p>
<p>Is identical to the difference type of iterator and const_iterator.</p>
</li>
<li class="listitem">
<p>
<span class="keyword">typedef</span> <span class="emphasis"><em><span class="identifier">implementation</span><span class="special">-</span><span class="identifier">defined</span></em></span> <a name="boost.unordered_map.iterator"></a><span class="identifier">iterator</span><span class="special">;</span></p>
<p>An iterator whose value type is value_type. </p>
<p>The iterator category is at least a forward iterator.</p>
<p>Convertible to const_iterator.</p>
</li>
<li class="listitem">
<p>
<span class="keyword">typedef</span> <span class="emphasis"><em><span class="identifier">implementation</span><span class="special">-</span><span class="identifier">defined</span></em></span> <a name="boost.unordered_map.const_iterator"></a><span class="identifier">const_iterator</span><span class="special">;</span></p>
<p>A constant iterator whose value type is value_type. </p>
<p>The iterator category is at least a forward iterator.</p>
</li>
<li class="listitem">
<p>
<span class="keyword">typedef</span> <span class="emphasis"><em><span class="identifier">implementation</span><span class="special">-</span><span class="identifier">defined</span></em></span> <a name="boost.unordered_map.local_iterator"></a><span class="identifier">local_iterator</span><span class="special">;</span></p>
<p>An iterator with the same value type, difference type and pointer and reference type as iterator.</p>
<p>A local_iterator object can be used to iterate through a single bucket.</p>
</li>
<li class="listitem">
<p>
<span class="keyword">typedef</span> <span class="emphasis"><em><span class="identifier">implementation</span><span class="special">-</span><span class="identifier">defined</span></em></span> <a name="boost.unordered_map.const_local_iterator"></a><span class="identifier">const_local_iterator</span><span class="special">;</span></p>
<p>A constant iterator with the same value type, difference type and pointer and reference type as const_iterator.</p>
<p>A const_local_iterator object can be used to iterate through a single bucket.</p>
</li>
</ol></div>
</div>
<div class="refsect2">
<a name="id3678148"></a><h3>
<a name="boost.unordered_mapconstruct-copy-destruct"></a><code class="computeroutput">unordered_map</code> 
        public
       construct/copy/destruct</h3>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<pre class="literallayout"><span class="keyword">explicit</span> <a name="id1640360-bb"></a><span class="identifier">unordered_map</span><span class="special">(</span><span class="identifier">size_type</span> n <span class="special">=</span> <span class="emphasis"><em><span class="identifier">implementation</span><span class="special">-</span><span class="identifier">defined</span></em></span><span class="special">,</span> 
                       <span class="identifier">hasher</span> <span class="keyword">const</span><span class="special">&amp;</span> hf <span class="special">=</span> <span class="identifier">hasher</span><span class="special">(</span><span class="special">)</span><span class="special">,</span> 
                       <span class="identifier">key_equal</span> <span class="keyword">const</span><span class="special">&amp;</span> eq <span class="special">=</span> <span class="identifier">key_equal</span><span class="special">(</span><span class="special">)</span><span class="special">,</span> 
                       <span class="identifier">allocator_type</span> <span class="keyword">const</span><span class="special">&amp;</span> a <span class="special">=</span> <span class="identifier">allocator_type</span><span class="special">(</span><span class="special">)</span><span class="special">)</span><span class="special">;</span></pre>
<p>Constructs an empty container with at least n buckets, using hf as the hash function, eq as the key equality predicate, a as the allocator and a maximum load factor of 1.0.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Postconditions:</span></p></td>
<td><code class="computeroutput"><a class="link" href="unordered_map.html#id1637628-bb">size</a>() == 0</code></td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <a class="link" href="../InputIterator.html" title="Concept InputIterator">InputIterator</a><span class="special">&gt;</span> 
  <a name="id1640442-bb"></a><span class="identifier">unordered_map</span><span class="special">(</span><span class="identifier">InputIterator</span> f<span class="special">,</span> <span class="identifier">InputIterator</span> l<span class="special">,</span> 
                <span class="identifier">size_type</span> n <span class="special">=</span> <span class="emphasis"><em><span class="identifier">implementation</span><span class="special">-</span><span class="identifier">defined</span></em></span><span class="special">,</span> 
                <span class="identifier">hasher</span> <span class="keyword">const</span><span class="special">&amp;</span> hf <span class="special">=</span> <span class="identifier">hasher</span><span class="special">(</span><span class="special">)</span><span class="special">,</span> 
                <span class="identifier">key_equal</span> <span class="keyword">const</span><span class="special">&amp;</span> eq <span class="special">=</span> <span class="identifier">key_equal</span><span class="special">(</span><span class="special">)</span><span class="special">,</span> 
                <span class="identifier">allocator_type</span> <span class="keyword">const</span><span class="special">&amp;</span> a <span class="special">=</span> <span class="identifier">allocator_type</span><span class="special">(</span><span class="special">)</span><span class="special">)</span><span class="special">;</span></pre>
<p>Constructs an empty container with at least n buckets, using hf as the hash function, eq as the key equality predicate, a as the allocator and a maximum load factor of 1.0 and inserts the elements from [f, l) into it.</p>
</li>
<li class="listitem">
<pre class="literallayout"><a name="id1639432-bb"></a><span class="identifier">unordered_map</span><span class="special">(</span><span class="identifier">unordered_map</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="special">)</span><span class="special">;</span></pre>
<p>The copy constructor. Copies the contained elements, hash function, predicate, maximum load factor and allocator.</p>
<p>If <code class="computeroutput">Allocator::select_on_container_copy_construction</code>
              exists and has the right signature, the allocator will be
              constructed from its result.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Requires:</span></p></td>
<td><p><code class="computeroutput">value_type</code> is copy constructible</p></td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><a name="id1639473-bb"></a><span class="identifier">unordered_map</span><span class="special">(</span><span class="identifier">unordered_map</span> <span class="special">&amp;&amp;</span><span class="special">)</span><span class="special">;</span></pre>
<p>The move constructor.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td><p>This is implemented using Boost.Move.</p></td>
</tr>
<tr>
<td><p><span class="term">Requires:</span></p></td>
<td>
<p>
                <code class="computeroutput">value_type</code> is move constructible.
              </p>
<p>
                On compilers without rvalue reference support the
                emulation does not support moving without calling
                <code class="computeroutput">boost::move</code> if <code class="computeroutput">value_type</code> is
                not copyable. So, for example, you can't return the
                container from a function.
              </p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="keyword">explicit</span> <a name="id1639528-bb"></a><span class="identifier">unordered_map</span><span class="special">(</span><span class="identifier">Allocator</span> <span class="keyword">const</span><span class="special">&amp;</span> a<span class="special">)</span><span class="special">;</span></pre>
<p>Constructs an empty container, using allocator <code class="computeroutput">a</code>.</p>
</li>
<li class="listitem">
<pre class="literallayout"><a name="id1639338-bb"></a><span class="identifier">unordered_map</span><span class="special">(</span><span class="identifier">unordered_map</span> <span class="keyword">const</span><span class="special">&amp;</span> x<span class="special">,</span> <span class="identifier">Allocator</span> <span class="keyword">const</span><span class="special">&amp;</span> a<span class="special">)</span><span class="special">;</span></pre>
<p>Constructs an container, copying <code class="computeroutput">x</code>'s contained elements, hash function, predicate, maximum load factor, but using allocator <code class="computeroutput">a</code>.</p>
</li>
<li class="listitem">
<pre class="literallayout"><a name="id1639178-bb"></a><span class="special">~</span><span class="identifier">unordered_map</span><span class="special">(</span><span class="special">)</span><span class="special">;</span></pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Notes:</span></p></td>
<td><p>The destructor is applied to every element, and all memory is deallocated</p></td>
</tr></tbody>
</table></div>
</li>
</ol></div>
</div>
<pre class="literallayout"><span class="identifier">unordered_map</span><span class="special">&amp;</span> <a name="id1639190-bb"></a><span class="keyword">operator</span><span class="special">=</span><span class="special">(</span><span class="identifier">unordered_map</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="special">)</span><span class="special">;</span></pre>
<p>The assignment operator. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator.</p>
<p>If <code class="computeroutput">Alloc::propagate_on_container_copy_assignment</code>
              exists and <code class="computeroutput">Alloc::propagate_on_container_copy_assignment::value
              </code> is true, the allocator is overwritten, if not the
              copied elements are created using the existing
              allocator.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Requires:</span></p></td>
<td><p><code class="computeroutput">value_type</code> is copy constructible</p></td>
</tr></tbody>
</table></div>
<pre class="literallayout"><span class="identifier">unordered_map</span><span class="special">&amp;</span> <a name="id1639242-bb"></a><span class="keyword">operator</span><span class="special">=</span><span class="special">(</span><span class="identifier">unordered_map</span> <span class="special">&amp;&amp;</span><span class="special">)</span><span class="special">;</span></pre>
<p>The move assignment operator.</p>
<p>If <code class="computeroutput">Alloc::propagate_on_container_move_assignment</code>
              exists and <code class="computeroutput">Alloc::propagate_on_container_move_assignment::value
              </code> is true, the allocator is overwritten, if not the
              moved elements are created using the existing
              allocator.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td><p>
                On compilers without rvalue references, this is emulated using
                Boost.Move. Note that on some compilers the copy assignment
                operator may be used in some circumstances.
              </p></td>
</tr>
<tr>
<td><p><span class="term">Requires:</span></p></td>
<td><p>
                <code class="computeroutput">value_type</code> is move constructible.
              </p></td>
</tr>
</tbody>
</table></div>
<pre class="literallayout"><span class="identifier">allocator_type</span> <a name="id1639306-bb"></a><span class="identifier">get_allocator</span><span class="special">(</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></pre>
<div class="refsect2">
<a name="id3679183"></a><h3>
<a name="id1639317-bb"></a><code class="computeroutput">unordered_map</code> size and capacity</h3>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<pre class="literallayout"><span class="keyword">bool</span> <a name="id1639322-bb"></a><span class="identifier">empty</span><span class="special">(</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><code class="computeroutput"><a class="link" href="unordered_map.html#id1637628-bb">size</a>() == 0</code></td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="identifier">size_type</span> <a name="id1637628-bb"></a><span class="identifier">size</span><span class="special">(</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><code class="computeroutput">std::distance(<a class="link" href="unordered_map.html#id1637682-bb">begin</a>(), <a class="link" href="unordered_map.html#id1637706-bb">end</a>())</code></td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="identifier">size_type</span> <a name="id1637655-bb"></a><span class="identifier">max_size</span><span class="special">(</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td>
<code class="computeroutput"><a class="link" href="unordered_map.html#id1637628-bb">size</a>()</code> of the largest possible container.
              </td>
</tr></tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2">
<a name="id3679394"></a><h3>
<a name="id1637677-bb"></a><code class="computeroutput">unordered_map</code> iterators</h3>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<pre class="literallayout"><a name="id1637682-bb"></a><span class="identifier">iterator</span> <a name="id1637686-bb"></a><span class="identifier">begin</span><span class="special">(</span><span class="special">)</span><span class="special">;</span>
<span class="identifier">const_iterator</span> <a name="id1637691-bb"></a><span class="identifier">begin</span><span class="special">(</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.
              </td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><a name="id1637706-bb"></a><span class="identifier">iterator</span> <a name="id1637710-bb"></a><span class="identifier">end</span><span class="special">(</span><span class="special">)</span><span class="special">;</span>
<span class="identifier">const_iterator</span> <a name="id1637718-bb"></a><span class="identifier">end</span><span class="special">(</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td>An iterator which refers to the past-the-end value for the container.
              </td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="identifier">const_iterator</span> <a name="id1637734-bb"></a><span class="identifier">cbegin</span><span class="special">(</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td>A constant iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.
              </td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="identifier">const_iterator</span> <a name="id1637752-bb"></a><span class="identifier">cend</span><span class="special">(</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td>A constant iterator which refers to the past-the-end value for the container.
              </td>
</tr></tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2">
<a name="id3679690"></a><h3>
<a name="id1637770-bb"></a><code class="computeroutput">unordered_map</code> modifiers</h3>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<pre class="literallayout"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span><span class="special">...</span> Args<span class="special">&gt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">iterator</span><span class="special">,</span> <span class="keyword">bool</span><span class="special">&gt;</span> <a name="id1637775-bb"></a><span class="identifier">emplace</span><span class="special">(</span><span class="identifier">Args</span><span class="special">&amp;&amp;</span><span class="special">...</span> args<span class="special">)</span><span class="special">;</span></pre>
<p>Inserts an object, constructed with the arguments <code class="computeroutput">args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td>
<p>The bool component of the return type is true if an insert took place.</p>
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>If an exception is thrown by an operation other than a call to <code class="computeroutput">hasher</code> the function has no effect.</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td>
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.</p>
<p>Pointers and references to elements are never invalidated.</p>
<p>If the compiler doesn't support variadic template arguments or rvalue
                      references, this is emulated for up to 10 arguments, with no support
                      for rvalue references or move semantics.</p>
<p>Since existing <code class="computeroutput">std::pair</code> implementations don't support
                      <code class="computeroutput">std::piecewise_construct</code> this emulates it,
                      but using <code class="computeroutput">boost::unordered::piecewise_construct</code>.</p>
<p>In version of Boost before 1.48 this emulated the variadic pair
                      constructor from older C++0x drafts. For backwards compatability
                      this can be enabled by defining the macro
                      <code class="computeroutput">BOOST_UNORDERED_DEPRECATED_PAIR_CONSTRUCT</code>.</p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span><span class="special">...</span> Args<span class="special">&gt;</span> 
  <span class="identifier">iterator</span> <a name="id1637901-bb"></a><span class="identifier">emplace_hint</span><span class="special">(</span><span class="identifier">const_iterator</span> hint<span class="special">,</span> <span class="identifier">Args</span><span class="special">&amp;&amp;</span><span class="special">...</span> args<span class="special">)</span><span class="special">;</span></pre>
<p>Inserts an object, constructed with the arguments <code class="computeroutput">args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
<p><code class="computeroutput">hint</code> is a suggestion to where the element should be inserted.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>If an exception is thrown by an operation other than a call to <code class="computeroutput">hasher</code> the function has no effect.</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td>
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key. </p>
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.</p>
<p>Pointers and references to elements are never invalidated.</p>
<p>If the compiler doesn't support variadic template arguments or rvalue
                      references, this is emulated for up to 10 arguments, with no support
                      for rvalue references or move semantics.</p>
<p>Since existing <code class="computeroutput">std::pair</code> implementations don't support
                      <code class="computeroutput">std::piecewise_construct</code> this emulates it,
                      but using <code class="computeroutput">boost::unordered::piecewise_construct</code>.</p>
<p>In version of Boost before 1.48 this emulated the variadic pair
                      constructor from older C++0x drafts. For backwards compatability
                      this can be enabled by defining the macro
                      <code class="computeroutput">BOOST_UNORDERED_DEPRECATED_PAIR_CONSTRUCT</code>.</p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">iterator</span><span class="special">,</span> <span class="keyword">bool</span><span class="special">&gt;</span> <a name="id1638047-bb"></a><span class="identifier">insert</span><span class="special">(</span><span class="identifier">value_type</span> <span class="keyword">const</span><span class="special">&amp;</span> obj<span class="special">)</span><span class="special">;</span></pre>
<p>Inserts <code class="computeroutput">obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td>
<p>The bool component of the return type is true if an insert took place.</p>
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>If an exception is thrown by an operation other than a call to <code class="computeroutput">hasher</code> the function has no effect.</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td>
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.</p>
<p>Pointers and references to elements are never invalidated.</p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="identifier">iterator</span> <a name="id1638122-bb"></a><span class="identifier">insert</span><span class="special">(</span><span class="identifier">const_iterator</span> hint<span class="special">,</span> <span class="identifier">value_type</span> <span class="keyword">const</span><span class="special">&amp;</span> obj<span class="special">)</span><span class="special">;</span></pre>
<p>Inserts <code class="computeroutput">obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
<p>hint is a suggestion to where the element should be inserted.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>If an exception is thrown by an operation other than a call to <code class="computeroutput">hasher</code> the function has no effect.</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td>
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key. </p>
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.</p>
<p>Pointers and references to elements are never invalidated.</p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <a class="link" href="../InputIterator.html" title="Concept InputIterator">InputIterator</a><span class="special">&gt;</span> 
  <span class="keyword">void</span> <a name="id1638213-bb"></a><span class="identifier">insert</span><span class="special">(</span><span class="identifier">InputIterator</span> first<span class="special">,</span> <span class="identifier">InputIterator</span> last<span class="special">)</span><span class="special">;</span></pre>
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>When inserting a single element, if an exception is thrown by an operation other than a call to <code class="computeroutput">hasher</code> the function has no effect.</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td>
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.</p>
<p>Pointers and references to elements are never invalidated.</p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="identifier">iterator</span> <a name="id1638290-bb"></a><span class="identifier">erase</span><span class="special">(</span><span class="identifier">const_iterator</span> position<span class="special">)</span><span class="special">;</span></pre>
<p>Erase the element pointed to by <code class="computeroutput">position</code>.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>The iterator following <code class="computeroutput">position</code> before the erasure.</p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>Only throws an exception if it is thrown by <code class="computeroutput">hasher</code> or <code class="computeroutput">key_equal</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td><p>
                  In older versions this could be inefficient because it had to search
                  through several buckets to find the position of the returned iterator.
                  The data structure has been changed so that this is no longer the case,
                  and the alternative erase methods have been deprecated.
                </p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="identifier">size_type</span> <a name="id1638363-bb"></a><span class="identifier">erase</span><span class="special">(</span><span class="identifier">key_type</span> <span class="keyword">const</span><span class="special">&amp;</span> k<span class="special">)</span><span class="special">;</span></pre>
<p>Erase all elements with key equivalent to <code class="computeroutput">k</code>.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>The number of elements erased.</p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>Only throws an exception if it is thrown by <code class="computeroutput">hasher</code> or <code class="computeroutput">key_equal</code>.</p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="identifier">iterator</span> <a name="id1638418-bb"></a><span class="identifier">erase</span><span class="special">(</span><span class="identifier">const_iterator</span> first<span class="special">,</span> <span class="identifier">const_iterator</span> last<span class="special">)</span><span class="special">;</span></pre>
<p>Erases the elements in the range from <code class="computeroutput">first</code> to <code class="computeroutput">last</code>.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>The iterator following the erased elements - i.e. <code class="computeroutput">last</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td>
<p>Only throws an exception if it is thrown by <code class="computeroutput">hasher</code> or <code class="computeroutput">key_equal</code>.</p>
<p>In this implementation, this overload doesn't call either function object's methods so it is no throw, but this might not be true in other implementations.</p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="keyword">void</span> <a name="id1638498-bb"></a><span class="identifier">quick_erase</span><span class="special">(</span><span class="identifier">const_iterator</span> position<span class="special">)</span><span class="special">;</span></pre>
<p>Erase the element pointed to by <code class="computeroutput">position</code>.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td>
<p>Only throws an exception if it is thrown by <code class="computeroutput">hasher</code> or <code class="computeroutput">key_equal</code>.</p>
<p>In this implementation, this overload doesn't call either function object's methods so it is no throw, but this might not be true in other implementations.</p>
</td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td><p>
                  This method was implemented because returning an iterator to
                  the next element from <code class="computeroutput">erase</code> was expensive, but
                  the container has been redesigned so that is no longer the
                  case. So this method is now deprecated.
                </p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="keyword">void</span> <a name="id1638567-bb"></a><span class="identifier">erase_return_void</span><span class="special">(</span><span class="identifier">const_iterator</span> position<span class="special">)</span><span class="special">;</span></pre>
<p>Erase the element pointed to by <code class="computeroutput">position</code>.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td>
<p>Only throws an exception if it is thrown by <code class="computeroutput">hasher</code> or <code class="computeroutput">key_equal</code>.</p>
<p>In this implementation, this overload doesn't call either function object's methods so it is no throw, but this might not be true in other implementations.</p>
</td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td><p>
                  This method was implemented because returning an iterator to
                  the next element from <code class="computeroutput">erase</code> was expensive, but
                  the container has been redesigned so that is no longer the
                  case. So this method is now deprecated.
                </p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="keyword">void</span> <a name="id1638637-bb"></a><span class="identifier">clear</span><span class="special">(</span><span class="special">)</span><span class="special">;</span></pre>
<p>Erases all elements in the container.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Postconditions:</span></p></td>
<td><p><code class="computeroutput"><a class="link" href="unordered_map.html#id1637628-bb">size</a>() == 0</code></p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>Never throws an exception.</p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="keyword">void</span> <a name="id1638674-bb"></a><span class="identifier">swap</span><span class="special">(</span><span class="identifier">unordered_map</span><span class="special">&amp;</span><span class="special">)</span><span class="special">;</span></pre>
<p>Swaps the contents of the container with the parameter.</p>
<p>If <code class="computeroutput">Allocator::propagate_on_container_swap</code> is declared and
                  <code class="computeroutput">Allocator::propagate_on_container_swap::value</code> is true then the
                  containers' allocators are swapped. Otherwise, swapping with unequal allocators
                  results in undefined behavior.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>Doesn't throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code class="computeroutput">key_equal</code> or <code class="computeroutput">hasher</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td><p>The exception specifications aren't quite the same as the C++11 standard, as
                  the equality predieate and hash function are swapped using their copy constructors.</p></td>
</tr>
</tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2">
<a name="id3681121"></a><h3>
<a name="id1638745-bb"></a><code class="computeroutput">unordered_map</code> observers</h3>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<pre class="literallayout"><span class="identifier">hasher</span> <a name="id1638749-bb"></a><span class="identifier">hash_function</span><span class="special">(</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td>The container's hash function.
              </td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="identifier">key_equal</span> <a name="id1638765-bb"></a><span class="identifier">key_eq</span><span class="special">(</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td>The container's key equality predicate.
              </td>
</tr></tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2">
<a name="id3681244"></a><h3>
<a name="id1638783-bb"></a><code class="computeroutput">unordered_map</code> lookup</h3>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<pre class="literallayout"><a name="id1638787-bb"></a><span class="identifier">iterator</span> <a name="id1638792-bb"></a><span class="identifier">find</span><span class="special">(</span><span class="identifier">key_type</span> <span class="keyword">const</span><span class="special">&amp;</span> k<span class="special">)</span><span class="special">;</span>
<span class="identifier">const_iterator</span> <a name="id1638810-bb"></a><span class="identifier">find</span><span class="special">(</span><span class="identifier">key_type</span> <span class="keyword">const</span><span class="special">&amp;</span> k<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> CompatibleKey<span class="special">,</span> <span class="keyword">typename</span> CompatibleHash<span class="special">,</span> 
         <span class="keyword">typename</span> CompatiblePredicate<span class="special">&gt;</span> 
  <span class="identifier">iterator</span> <a name="id1638830-bb"></a><span class="identifier">find</span><span class="special">(</span><span class="identifier">CompatibleKey</span> <span class="keyword">const</span><span class="special">&amp;</span> k<span class="special">,</span> <span class="identifier">CompatibleHash</span> <span class="keyword">const</span><span class="special">&amp;</span> hash<span class="special">,</span> 
                <span class="identifier">CompatiblePredicate</span> <span class="keyword">const</span><span class="special">&amp;</span> eq<span class="special">)</span><span class="special">;</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> CompatibleKey<span class="special">,</span> <span class="keyword">typename</span> CompatibleHash<span class="special">,</span> 
         <span class="keyword">typename</span> CompatiblePredicate<span class="special">&gt;</span> 
  <span class="identifier">const_iterator</span> 
  <a name="id1638889-bb"></a><span class="identifier">find</span><span class="special">(</span><span class="identifier">CompatibleKey</span> <span class="keyword">const</span><span class="special">&amp;</span> k<span class="special">,</span> <span class="identifier">CompatibleHash</span> <span class="keyword">const</span><span class="special">&amp;</span> hash<span class="special">,</span> 
       <span class="identifier">CompatiblePredicate</span> <span class="keyword">const</span><span class="special">&amp;</span> eq<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>An iterator pointing to an element with key equivalent to <code class="computeroutput">k</code>, or <code class="computeroutput">b.end()</code> if no such element exists.</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td><p>
                The templated overloads are a non-standard extensions which
                allows you to use a compatible hash function and equality
                predicate for a key of a different type in order to avoid
                an expensive type cast. In general, its use is not encouraged.
              </p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="identifier">size_type</span> <a name="id1638977-bb"></a><span class="identifier">count</span><span class="special">(</span><span class="identifier">key_type</span> <span class="keyword">const</span><span class="special">&amp;</span> k<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>The number of elements with key equivalent to <code class="computeroutput">k</code>.</p></td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><a name="id1639011-bb"></a><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">iterator</span><span class="special">,</span> <span class="identifier">iterator</span><span class="special">&gt;</span> <a name="id1639015-bb"></a><span class="identifier">equal_range</span><span class="special">(</span><span class="identifier">key_type</span> <span class="keyword">const</span><span class="special">&amp;</span> k<span class="special">)</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">const_iterator</span><span class="special">,</span> <span class="identifier">const_iterator</span><span class="special">&gt;</span> <a name="id1639034-bb"></a><span class="identifier">equal_range</span><span class="special">(</span><span class="identifier">key_type</span> <span class="keyword">const</span><span class="special">&amp;</span> k<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>A range containing all elements with key equivalent to <code class="computeroutput">k</code>.
                  If the container doesn't container any such elements, returns
                  <code class="computeroutput">std::make_pair(b.end(),b.end())</code>.
                  </p></td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="identifier">mapped_type</span><span class="special">&amp;</span> <a name="id1639084-bb"></a><span class="keyword">operator</span><span class="special">[</span><span class="special">]</span><span class="special">(</span><span class="identifier">key_type</span> <span class="keyword">const</span><span class="special">&amp;</span> k<span class="special">)</span><span class="special">;</span></pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Effects:</span></p></td>
<td><p>If the container does not already contain an elements with a key equivalent to <code class="computeroutput">k</code>, inserts the value <code class="computeroutput">std::pair&lt;key_type const, mapped_type&gt;(k, mapped_type())</code></p></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>A reference to <code class="computeroutput">x.second</code> where x is the element already in the container, or the newly inserted element with a key equivalent to <code class="computeroutput">k</code></p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>If an exception is thrown by an operation other than a call to <code class="computeroutput">hasher</code> the function has no effect.</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td>
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.</p>
<p>Pointers and references to elements are never invalidated.</p>
</td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><a name="id1639161-bb"></a><span class="identifier">Mapped</span><span class="special">&amp;</span> <a name="id1639166-bb"></a><span class="identifier">at</span><span class="special">(</span><span class="identifier">key_type</span> <span class="keyword">const</span><span class="special">&amp;</span> k<span class="special">)</span><span class="special">;</span>
<span class="identifier">Mapped</span> <span class="keyword">const</span><span class="special">&amp;</span> <a name="id1637381-bb"></a><span class="identifier">at</span><span class="special">(</span><span class="identifier">key_type</span> <span class="keyword">const</span><span class="special">&amp;</span> k<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>A reference to <code class="computeroutput">x.second</code> where <code class="computeroutput">x</code> is the (unique) element whose key is equivalent to <code class="computeroutput">k</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>An exception object of type <code class="computeroutput">std::out_of_range</code> if no such element is present.</p></td>
</tr>
</tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2">
<a name="id3682233"></a><h3>
<a name="id1637430-bb"></a><code class="computeroutput">unordered_map</code> bucket interface</h3>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<pre class="literallayout"><span class="identifier">size_type</span> <a name="id1637434-bb"></a><span class="identifier">bucket_count</span><span class="special">(</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>The number of buckets.</p></td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="identifier">size_type</span> <a name="id1637454-bb"></a><span class="identifier">max_bucket_count</span><span class="special">(</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>An upper bound on the number of buckets.</p></td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="identifier">size_type</span> <a name="id1637474-bb"></a><span class="identifier">bucket_size</span><span class="special">(</span><span class="identifier">size_type</span> n<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Requires:</span></p></td>
<td><p><code class="computeroutput">n &lt; <a class="link" href="unordered_map.html#id1637434-bb">bucket_count</a>()</code></p></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>The number of elements in bucket <code class="computeroutput">n</code>.</p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="identifier">size_type</span> <a name="id1637521-bb"></a><span class="identifier">bucket</span><span class="special">(</span><span class="identifier">key_type</span> <span class="keyword">const</span><span class="special">&amp;</span> k<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>The index of the bucket which would contain an element with key <code class="computeroutput">k</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Postconditions:</span></p></td>
<td><p>The return value is less than <code class="computeroutput">bucket_count()</code></p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><a name="id1637565-bb"></a><span class="identifier">local_iterator</span> <a name="id1637570-bb"></a><span class="identifier">begin</span><span class="special">(</span><span class="identifier">size_type</span> n<span class="special">)</span><span class="special">;</span>
<span class="identifier">const_local_iterator</span> <a name="id1637588-bb"></a><span class="identifier">begin</span><span class="special">(</span><span class="identifier">size_type</span> n<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Requires:</span></p></td>
<td><p><code class="computeroutput">n</code> shall be in the range <code class="computeroutput">[0, bucket_count())</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>A local iterator pointing the first element in the bucket with index <code class="computeroutput">n</code>.</p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><a name="id1634789-bb"></a><span class="identifier">local_iterator</span> <a name="id1634794-bb"></a><span class="identifier">end</span><span class="special">(</span><span class="identifier">size_type</span> n<span class="special">)</span><span class="special">;</span>
<span class="identifier">const_local_iterator</span> <a name="id1634812-bb"></a><span class="identifier">end</span><span class="special">(</span><span class="identifier">size_type</span> n<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Requires:</span></p></td>
<td><p><code class="computeroutput">n</code> shall be in the range <code class="computeroutput">[0, bucket_count())</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>A local iterator pointing the 'one past the end' element in the bucket with index <code class="computeroutput">n</code>.</p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="identifier">const_local_iterator</span> <a name="id1636502-bb"></a><span class="identifier">cbegin</span><span class="special">(</span><span class="identifier">size_type</span> n<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Requires:</span></p></td>
<td><p><code class="computeroutput">n</code> shall be in the range <code class="computeroutput">[0, bucket_count())</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>A constant local iterator pointing the first element in the bucket with index <code class="computeroutput">n</code>.</p></td>
</tr>
</tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="identifier">const_local_iterator</span> <a name="id1636550-bb"></a><span class="identifier">cend</span><span class="special">(</span><span class="identifier">size_type</span> n<span class="special">)</span><span class="special">;</span></pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Requires:</span></p></td>
<td><p><code class="computeroutput">n</code> shall be in the range <code class="computeroutput">[0, bucket_count())</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>A constant local iterator pointing the 'one past the end' element in the bucket with index <code class="computeroutput">n</code>.</p></td>
</tr>
</tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2">
<a name="id3682925"></a><h3>
<a name="id1636599-bb"></a><code class="computeroutput">unordered_map</code> hash policy</h3>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<pre class="literallayout"><span class="keyword">float</span> <a name="id1636603-bb"></a><span class="identifier">load_factor</span><span class="special">(</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>The average number of elements per bucket.</p></td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="keyword">float</span> <a name="id1636623-bb"></a><span class="identifier">max_load_factor</span><span class="special">(</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>Returns the current maximum load factor.</p></td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="keyword">void</span> <a name="id1636643-bb"></a><span class="identifier">max_load_factor</span><span class="special">(</span><span class="keyword">float</span> z<span class="special">)</span><span class="special">;</span></pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Effects:</span></p></td>
<td><p>Changes the container's maximum load factor, using <code class="computeroutput">z</code> as a hint.</p></td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="keyword">void</span> <a name="id1636675-bb"></a><span class="identifier">rehash</span><span class="special">(</span><span class="identifier">size_type</span> n<span class="special">)</span><span class="special">;</span></pre>
<p>Changes the number of buckets so that there at least <code class="computeroutput">n</code> buckets, and so that the load factor is less than the maximum load factor.</p>
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>The function has no effect if an exception is thrown, unless it is thrown by the container's hash function or comparison function.</p></td>
</tr></tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2">
<a name="id3683176"></a><h3>
<a name="id1636725-bb"></a><code class="computeroutput">unordered_map</code> Equality Comparisons</h3>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<pre class="literallayout"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Key<span class="special">,</span> <span class="keyword">typename</span> Mapped<span class="special">,</span> <span class="keyword">typename</span> Hash<span class="special">,</span> <span class="keyword">typename</span> Pred<span class="special">,</span> 
         <span class="keyword">typename</span> Alloc<span class="special">&gt;</span> 
  <span class="keyword">bool</span> <a name="boost.unordered_map.operator==_id1636730"></a><span class="keyword">operator</span><span class="special">==</span><span class="special">(</span><span class="identifier">unordered_map</span><span class="special">&lt;</span><span class="identifier">Key</span><span class="special">,</span> <span class="identifier">Mapped</span><span class="special">,</span> <span class="identifier">Hash</span><span class="special">,</span> <span class="identifier">Pred</span><span class="special">,</span> <span class="identifier">Alloc</span><span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> x<span class="special">,</span> 
                  <span class="identifier">unordered_map</span><span class="special">&lt;</span><span class="identifier">Key</span><span class="special">,</span> <span class="identifier">Mapped</span><span class="special">,</span> <span class="identifier">Hash</span><span class="special">,</span> <span class="identifier">Pred</span><span class="special">,</span> <span class="identifier">Alloc</span><span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> y<span class="special">)</span><span class="special">;</span></pre>
<p>Return <code class="computeroutput">true</code> if <code class="computeroutput">x.size() ==
                y.size</code> and for every element in <code class="computeroutput">x</code>,
                there is an element in <code class="computeroutput">y</code> with the same
                for the same key, with an equal value (using
                <code class="computeroutput">operator==</code> to compare the value types).
                </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Notes:</span></p></td>
<td>
<p>The behavior of this function was changed to match
                  the C++11 standard in Boost 1.48. If you wish to use
                  the old behaviour, define the macro
                  <code class="computeroutput">BOOST_UNORDERED_DEPRECATED_EQUALITY</code>.</p>
<p>Behavior is undefined if the two containers don't have
                    equivalent equality predicates.</p>
</td>
</tr></tbody>
</table></div>
</li>
<li class="listitem">
<pre class="literallayout"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Key<span class="special">,</span> <span class="keyword">typename</span> Mapped<span class="special">,</span> <span class="keyword">typename</span> Hash<span class="special">,</span> <span class="keyword">typename</span> Pred<span class="special">,</span> 
         <span class="keyword">typename</span> Alloc<span class="special">&gt;</span> 
  <span class="keyword">bool</span> <a name="boost.unordered_map.operator!=_id1636846"></a><span class="keyword">operator</span><span class="special">!=</span><span class="special">(</span><span class="identifier">unordered_map</span><span class="special">&lt;</span><span class="identifier">Key</span><span class="special">,</span> <span class="identifier">Mapped</span><span class="special">,</span> <span class="identifier">Hash</span><span class="special">,</span> <span class="identifier">Pred</span><span class="special">,</span> <span class="identifier">Alloc</span><span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> x<span class="special">,</span> 
                  <span class="identifier">unordered_map</span><span class="special">&lt;</span><span class="identifier">Key</span><span class="special">,</span> <span class="identifier">Mapped</span><span class="special">,</span> <span class="identifier">Hash</span><span class="special">,</span> <span class="identifier">Pred</span><span class="special">,</span> <span class="identifier">Alloc</span><span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> y<span class="special">)</span><span class="special">;</span></pre>
<p>Return <code class="computeroutput">false</code> if <code class="computeroutput">x.size() ==
                y.size</code> and for every element in <code class="computeroutput">x</code>,
                there is an element in <code class="computeroutput">y</code> with the same
                for the same key, with an equal value (using
                <code class="computeroutput">operator==</code> to compare the value types).
                </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Notes:</span></p></td>
<td>
<p>The behavior of this function was changed to match
                  the C++11 standard in Boost 1.48. If you wish to use
                  the old behaviour, define the macro
                  <code class="computeroutput">BOOST_UNORDERED_DEPRECATED_EQUALITY</code>.</p>
<p>Behavior is undefined if the two containers don't have
                    equivalent equality predicates.</p>
</td>
</tr></tbody>
</table></div>
</li>
</ol></div>
</div>
<div class="refsect2">
<a name="id3683808"></a><h3>
<a name="id1636963-bb"></a><code class="computeroutput">unordered_map</code> swap</h3>
<div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
<pre class="literallayout"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Key<span class="special">,</span> <span class="keyword">typename</span> Mapped<span class="special">,</span> <span class="keyword">typename</span> Hash<span class="special">,</span> <span class="keyword">typename</span> Pred<span class="special">,</span> 
         <span class="keyword">typename</span> Alloc<span class="special">&gt;</span> 
  <span class="keyword">void</span> <a name="boost.unordered_map.swap_id1636968"></a><span class="identifier">swap</span><span class="special">(</span><span class="identifier">unordered_map</span><span class="special">&lt;</span><span class="identifier">Key</span><span class="special">,</span> <span class="identifier">Mapped</span><span class="special">,</span> <span class="identifier">Hash</span><span class="special">,</span> <span class="identifier">Pred</span><span class="special">,</span> <span class="identifier">Alloc</span><span class="special">&gt;</span><span class="special">&amp;</span> x<span class="special">,</span> 
            <span class="identifier">unordered_map</span><span class="special">&lt;</span><span class="identifier">Key</span><span class="special">,</span> <span class="identifier">Mapped</span><span class="special">,</span> <span class="identifier">Hash</span><span class="special">,</span> <span class="identifier">Pred</span><span class="special">,</span> <span class="identifier">Alloc</span><span class="special">&gt;</span><span class="special">&amp;</span> y<span class="special">)</span><span class="special">;</span></pre>
<p>Swaps the contents of <code class="computeroutput">x</code> and <code class="computeroutput">y</code>.</p>
<p>If <code class="computeroutput">Allocator::propagate_on_container_swap</code> is declared and
                  <code class="computeroutput">Allocator::propagate_on_container_swap::value</code> is true then the
                  containers' allocators are swapped. Otherwise, swapping with unequal allocators
                  results in undefined behavior.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Effects:</span></p></td>
<td><p><code class="computeroutput">x.swap(y)</code></p></td>
</tr>
<tr>
<td><p><span class="term">Throws:</span></p></td>
<td><p>Doesn't throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code class="computeroutput">key_equal</code> or <code class="computeroutput">hasher</code>.</p></td>
</tr>
<tr>
<td><p><span class="term">Notes:</span></p></td>
<td><p>The exception specifications aren't quite the same as the C++11 standard, as
                  the equality predieate and hash function are swapped using their copy constructors.</p></td>
</tr>
</tbody>
</table></div>
</li></ol></div>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2003, 2004 Jeremy B. Maitin-Shepard<br>Copyright &#169; 2005-2008 Daniel
      James<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="unordered_multiset.html"><img src="../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../unordered/reference.html#header.boost.unordered_map_hpp"><img src="../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="unordered_multimap.html"><img src="../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
